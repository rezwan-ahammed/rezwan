<!DOCTYPE html>
<html>

  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap">
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+Bengali:wght@100..900&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Lobster+Two&display=swap" rel="stylesheet">
<style>
        :root {
            --primary-color: #4285f4;
            --secondary-color: #f2f2f2;
            --text-color: #333;
            --font-family: 'Roboto', 'Noto Serif Bengali', sans-serif;
            --ripple-color: rgba(0, 0, 0, 0.2); 
        }

        body {
            font-family: var(--font-family);
            background-color: #fff;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        .container {
            flex: 0.83;
            max-width: 600px;
            margin: 0px 0px;
            background-color: #fff;
            border-radius: 0px;
            padding-top: 65px;
            padding-bottom: 30px;
            height: 100%;
        }

        .chat-window {
            height: calc(100% - 50px);
            overflow-y: auto;
            padding: 10px;
        }

        .chat-container {
            margin-bottom: 10px;
        }

        .input-field {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 15px;
            outline: none;
            background: #eeeeee;
        }

        .input-container {
            display: flex;
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            display: flex;
            align-items: center;
            padding: 10px;
            background-color: #ffffff;
            transition: bottom 0.3s;
        }

        header {
            background-color: #ffffff;
            color: ;
            padding: 0px 8px;
            box-shadow: 0px 2px 4px rgba(0, 0, 0, 0.1);
            position: fixed;
            top: 0;
            width: 100%;
            transition: top 0.3s;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        header h2 {
            padding-left: 10px;
            font-family: 'Lobster Two', cursive;
        }

        .send-button,
        .add-conversation-button,
        .free-line-button,
        .delete-icon,
        .rename-icon {
            background-color: #fff;
            border: none;
            border-radius: 50%;
            padding: 8px;
            padding-left: 10px;
            margin-left: 10px;
            margin-right: 10px;
            cursor: pointer;
            outline: none;
            transition: background-color 0.2s;
            position: relative;
            overflow: hidden;
        }

        .send-button:hover,
        .add-conversation-button:hover,
        .free-line-button:hover,
        .delete-icon:hover,
        .rename-icon:hover {
            background: #eeeeee;
        }

        .send-button .material-icons,
        .add-conversation-button .material-icons,
        .free-line-button .material-icons,
        .delete-icon,
        .rename-icon {
            vertical-align: middle;
        }

        .conversation-container {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            margin-bottom: 30px;
        }

        .user-layout,
        .bot-layout {
            display: flex;
            margin-bottom: 10px;
        }

        .message {
    background-color: white;
    color: black;
    box-shadow: 1.5px 1.5px 1.5px 1px #bdbdbd;
    padding: 10px 15px;
    border-radius: 15px;
    max-width: 70%;
    word-wrap: break-word;
    white-space: pre-wrap;
}

        .chat-image {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            margin-right: 10px;
            margin-top: 5px;
        }

        .codewrap {
            background-color: #000000;
            border: 1px solid #ccc;
            border-radius: 8px;
            padding: 10px;
            margin: 10px;
            overflow-x: auto;
        }

        .code {
            font-family: Consolas, Menlo, monospace;
            white-space: pre-wrap;
            color: white;
        }

        .listwrap {
            background-color: black;
            border-radius: 8px;
            padding: 10px;
            margin: 10px;
            color: white;
            overflow-x: auto;
        }

        .navigation-drawer {
            position: fixed;
            left: -250px;
            top: 0;
            width: 250px;
            height: 100%;
            background-color: #f2f2f2;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: left 0.3s;
        }

        .navigation-drawer.open {
            left: 0;
        }

        .navigation-drawer-header {
            padding: 20px;
            background-color: #fff;
            color: #333;
            text-align: center;
        }

        .navigation-drawer-list {
            list-style-type: none;
            padding: 0;
            margin: 0;
            overflow-y: auto;
        }

        .navigation-drawer-list li {
            padding: 15px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            position: relative;
            display: flex;
            align-items: center;
        }

        .navigation-drawer-list li:last-child {
            border-bottom: none;
        }

        .navigation-drawer-list li.active {
            background-color: #e9e9e9;
        }

        .delete-icon,
        .rename-icon {
            cursor: pointer;
            margin-left: auto;
            margin-right: 10px;
            color: #333;
            font-size: 18px;
            position: relative;
            overflow: hidden;
        }

        .delete-icon:hover {
            color: red;
        }

        .rename-icon:hover {
            color: blue;
        }

        .send-button::before,
        .add-conversation-button::before,
        .free-line-button::before,
        .delete-icon::before,
        .rename-icon::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--ripple-color);
            border-radius: 50%;
            transform: scale(0);
            transition: transform 0.3s ease-out;
            pointer-events: none;
            z-index: -1;
        }

        .send-button:active::before,
        .add-conversation-button:active::before,
        .free-line-button:active::before,
        .delete-icon:active::before,
        .rename-icon:active::before {
            transform: scale(1.5);
            opacity: 0.7;
        }

        @media (max-width: 600px) {
            .container {
                max-width: 100%;
                padding-top: 100px;
            }

            .input-container {
                bottom: 10px;
            }

            .add-conversation-button {
                bottom: 10px;
                left: 10px;
            }

            .free-line-button {
                bottom: 10px;
                right: 10px;
            }
        }
		
		   code {
            color: #fff;
            border-radius: 8px;
            max-width: 900px;
        }

        pre {
		    background-color: #2d2d2d;
			padding: 8px;
			border-radius: 8px;
            white-space: pre-wrap;
            word-wrap: break-word;
            margin: 0;
            font-size: 14px;
            line-height: 1.6;
        }

       
        .copy-code {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: #444;
            border: none;
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
        }

        .copy-code:hover {
            background-color: #555;
        }
</style>
  </head>

  <body>
    <header id="header">
	  <h2><b>Intellimate</b><sup style="font-size:10px;"> by Rezwan</sup></h2>
	  <button class="add-conversation-button" id="addConversationButton">
		<i class="material-icons">add</i>
	  </button>
	  <button class="free-line-button" id="freeLineButton">
		<i class="material-icons">menu</i>
	  </button>
    </header>

    <div class="navigation-drawer" id="navigationDrawer">
	  <div class="navigation-drawer-header">
		<h3>Conversations</h3>
	  </div>
	  <ul class="navigation-drawer-list" id="conversationList">
	  </ul>
    </div>

    <div class="container">
	  <div class="chat-window" id="chat-window">
		<div class="chat-container" id="edit">
		  
		  <div id="loading-indicator" style="display:none;">
			<i class="material-icons">autorenew</i> Loading...
		  </div>
		</div>
	  </div>
	  <div class="input-container" id="inputContainer">
		<input type="enter" inputmode="next" id="input" placeholder="Type your message..."
		  class="input-field">
		<button id="button" class="send-button">
		  <i class="material-icons">send</i>
		</button>
	  </div>
    </div>

<script type="importmap">
        {
            "imports": {
                "@google/generative-ai": "https://esm.run/@google/generative-ai"
            }
        }
</script>

<script type="module">
         import { GoogleGenerativeAI } from "@google/generative-ai";

const API_KEY = "AIzaSyBmJtxnS2fsnSbFbscPMRhw50mMoLK6n_g";
const MAX_CONTEXT_LENGTH = 10; // Adjust this value based on the model's token limit
const DEFAULT_CONVERSATION = 'general';

const genAI = new GoogleGenerativeAI(API_KEY);

const conversationList = document.getElementById('conversationList');
const navigationDrawer = document.getElementById('navigationDrawer');
const addConversationButton = document.getElementById('addConversationButton');
const freeLineButton = document.getElementById('freeLineButton');
const inputContainer = document.getElementById('inputContainer');
const loadingIndicator = document.getElementById('loading-indicator');
const chatWindow = document.getElementById('edit');
const inputField = document.getElementById('input');
const sendButton = document.getElementById('button');

let currentConversation = DEFAULT_CONVERSATION;
let conversationData = {};

function initApp() {
    loadConversation();
    updateConversationList();
    displayConversation(currentConversation);
    setupEventListeners();
}

function setupEventListeners() {
    addConversationButton.addEventListener('click', handleAddConversation);
    freeLineButton.addEventListener('click', toggleNavigationDrawer);
    document.addEventListener('click', handleOutsideClick);
    sendButton.addEventListener('click', () => run());
    inputField.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') run();
    });
    inputField.addEventListener('focus', () => adjustInputContainer('60px'));
    inputField.addEventListener('blur', () => adjustInputContainer('0'));
}

async function handleAddConversation() {
    const initialMessage = prompt("Enter a message to start the conversation:");
    if (initialMessage) {
        try {
            const suggestedName = await generateConversationName(initialMessage);
            currentConversation = suggestedName;
            chatWindow.innerHTML = '';
            conversationData[currentConversation] = [];
            await run(initialMessage);
            navigationDrawer.classList.remove('open');
            saveCurrentConversation();
        } catch (error) {
            console.error("Error creating new conversation:", error);
            alert("An error occurred. Please try again.");
        }
    }
}

async function generateConversationName(initialMessage) {
    const model = genAI.getGenerativeModel({ model: "gemini-1.5-pro" });
    try {
        const result = await model.generateContent(`Suggest a 5-word name for a conversation starting with: "${initialMessage}"`);
        return result.response.text().trim();
    } catch (error) {
        console.error("Error generating conversation name:", error);
        return "New Conversation";
    }
}

function displayConversation(conversationName) {
    currentConversation = conversationName;
    const messages = conversationData[conversationName] || [];
    chatWindow.innerHTML = messages.map(createMessageHTML).join('');
    updateConversationList();
    chatWindow.scrollTop = chatWindow.scrollHeight;
    saveCurrentConversation();
}

function createMessageHTML(message) {
    return `
        <div class='conversation-container'>
            <div class='user-layout'>
                <img class='chat-image' src='https://icons.veryicon.com/png/o/miscellaneous/two-color-icon-library/user-286.png' alt='User Avatar'/>
                <article class='message'>${escapeHTML(message.user)}</article>
            </div>
            <div class='bot-layout'>
                <img class='chat-image' src='https://i.namu.wiki/i/Y_lZ0dEDSaRbYIoIS8SqjiySiwjE9PKPHcRKqZ4QWhhBsA-iV0337iMd5SkrcJsd24iDDlsCdVhgz6a1_wWeng.webp' alt='AI Avatar'/>
                <article class='message'>${formatAndReplace(message.ai)}</article>
            </div>
        </div>
    `;
}

function escapeHTML(str) {
    return str.replace(/[&<>'"]/g, 
        tag => ({
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            "'": '&#39;',
            '"': '&quot;'
        }[tag] || tag)
    );
}

function formatAndReplace(responseText) {
    if (typeof responseText !== 'string') {
        throw new TypeError('Input must be a string');
    }

    // Function to escape HTML in code blocks
    const escapeHtml = (text) => {
        return text
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#39;');
    };

    // Handle code blocks first
    let processedText = responseText.replace(/```([\s\S]*?)```/g, (match, code) => {
        const lines = code.trim().split('\n');
        const language = lines[0].trim() || 'plaintext';
        const codeContent = lines.slice(1).join('\n');
        const escapedCode = escapeHtml(codeContent);
        return `<pre><code class="language-${language}"></br>${escapedCode}</code></pre>`;
    });

    const patterns = [
        // Headers
        { pattern: /^### (.*?)$/gm, replacement: '<h3>$1</h3>' },
        { pattern: /^## (.*?)$/gm, replacement: '<h2>$1</h2>' },
        { pattern: /^# (.*?)$/gm, replacement: '<h1>$1</h1>' },
        
        // Text styling
        { pattern: /\*\*\*([^*]+)\*\*\*/g, replacement: '<strong><em>$1</em></strong>' },
        { pattern: /\*\*([^*]+)\*\*/g, replacement: '<strong>$1</strong>' },
        { pattern: /\*([^*]+)\*/g, replacement: '<em>$1</em>' },
        { pattern: /_([^_]+)_/g, replacement: '<em>$1</em>' },
        { pattern: /__([^_]+)__/g, replacement: '<u>$1</u>' },
        { pattern: /~~([^~]+)~~/g, replacement: '<del>$1</del>' },
        { pattern: /\|\|([^|]+)\|\|/g, replacement: '<span class="blur">$1</span>' },
        
        // Color formatting
        { pattern: /<clr_green>([^<]+)<clr_green>/g, replacement: '<span class="text-green">$1</span>' },
        { pattern: /<clr_white>([^<]+)<clr_white>/g, replacement: '<span class="text-white">$1</span>' },
        { pattern: /<clr_red>([^<]+)<clr_red>/g, replacement: '<span class="text-red">$1</span>' },
        { pattern: /<clr_yellow>([^<]+)<clr_yellow>/g, replacement: '<span class="text-yellow">$1</span>' },
        { pattern: /<clr_blue>([^<]+)<clr_blue>/g, replacement: '<span class="text-blue">$1</span>' },
        { pattern: /<clr_accent>([^<]+)<clr_accent>/g, replacement: '<span class="text-accent">$1</span>' },
        
        // Background colors
        { pattern: /<bg_accent>([^<]+)<bg_accent>/g, replacement: '<span class="bg-accent">$1</span>' },
        { pattern: /<bg_red>([^<]+)<bg_red>/g, replacement: '<span class="bg-red">$1</span>' },
        
        // Font sizes
        { pattern: /<h>([^<]+)<h>/g, replacement: '<span class="text-huge">$1</span>' },
        { pattern: /<b>([^<]+)<b>/g, replacement: '<span class="text-big">$1</span>' },
        { pattern: /<m>([^<]+)<m>/g, replacement: '<span class="text-medium">$1</span>' },
        { pattern: /<s>([^<]+)<s>/g, replacement: '<span class="text-small">$1</span>' },
        
        // Custom styles
        { pattern: /<custom_font>([^<]+)<custom_font>/g, replacement: '<span class="custom-font">$1</span>' },
        { 
            pattern: /<custom_color="#?([a-fA-F0-9]{8})">(.*?)<\/custom_color>/g, 
            replacement: (match, color, text) => `<span style="color:#${color}">${text}</span>`
        },
        { 
            pattern: /<custom_bgClr="#?([a-fA-F0-9]{8})">(.*?)<\/custom_bgClr>/g, 
            replacement: (match, color, text) => `<span style="background-color:#${color}">${text}</span>`
        },
        
        // Lists
        { pattern: /(?:^- (.*?)$\n?)+/gm, replacement: match => '<ul>' + match.replace(/^- (.*?)$/gm, '<li>$1</li>') + '</ul>' },
        { pattern: /(?:^\d+\. (.*?)$\n?)+/gm, replacement: match => '<ol>' + match.replace(/^\d+\. (.*?)$/gm, '<li>$1</li>') + '</ol>' },
        
        // Quotes
        { pattern: /^> (.*?)$/gm, replacement: '<blockquote>$1</blockquote>' },
        { pattern: /"([^"]+)"/g, replacement: '<q>$1</q>' },
        
        // Links
        { 
            pattern: /\[(.*?)\]\(link="(.*?)"\)/g, 
            replacement: '<a href="$2" class="clickable-link">$1</a>'
        },
        
        // Inline code
        { pattern: /`([^`]+)`/g, replacement: '<code>$1</code>' },
        
        // Horizontal rules
        { pattern: /^(---|\*\*\*)$/gm, replacement: '<hr>' }
    ];

    // Apply all patterns
    patterns.forEach(({ pattern, replacement }) => {
        processedText = typeof replacement === 'function'
            ? processedText.replace(pattern, replacement)
            : processedText.replace(pattern, replacement);
    });

    // Handle paragraphs
    processedText = processedText
        .split(/\n\n+/)
        .map(paragraph => paragraph.trim())
        .map(paragraph => {
            // Don't wrap pre-existing HTML elements in <p> tags
            if (paragraph.match(/^<(\/?)(h[1-6]|ul|ol|li|blockquote|hr|pre|code)/)) {
                return paragraph;
            }
            return `<p>${paragraph}</p>`;
        })
        .join('\n\n');

    return processedText;
}

function adjustInputContainer(bottom) {
    inputContainer.style.bottom = bottom;
}

function toggleNavigationDrawer() {
    navigationDrawer.classList.toggle('open');
}

function handleOutsideClick(event) {
    if (!navigationDrawer.contains(event.target) && 
        !addConversationButton.contains(event.target) && 
        !freeLineButton.contains(event.target)) {
        navigationDrawer.classList.remove('open');
    }
}

function saveConversation() {
    try {
        localStorage.setItem('conversations', JSON.stringify(conversationData));
        saveCurrentConversation();
    } catch (error) {
        console.error("Error saving conversation:", error);
    }
}

function saveCurrentConversation() {
    localStorage.setItem('currentConversation', currentConversation);
}

function loadConversation() {
    try {
        const conversations = JSON.parse(localStorage.getItem('conversations')) || {};
        conversationData = conversations;
        currentConversation = localStorage.getItem('currentConversation') || DEFAULT_CONVERSATION;
    } catch (error) {
        console.error("Error loading conversations:", error);
        conversationData = {};
        currentConversation = DEFAULT_CONVERSATION;
    }
}

function updateConversationList() {
    conversationList.innerHTML = '';
    for (let conversationName in conversationData) {
        let listItem = createConversationListItem(conversationName);
        conversationList.appendChild(listItem);
    }
}

function createConversationListItem(conversationName) {
    let listItem = document.createElement('li');
    listItem.textContent = conversationName;
    if (conversationName === currentConversation) {
        listItem.classList.add('active');
    }
    
    let deleteIcon = createIcon('delete', () => deleteConversation(conversationName));
    let renameIcon = createIcon('edit', () => renameConversation(conversationName));
    
    listItem.appendChild(deleteIcon);
    listItem.appendChild(renameIcon);
    listItem.addEventListener('click', () => {
        displayConversation(conversationName);
        navigationDrawer.classList.remove('open');
    });
    
    return listItem;
}

function createIcon(iconName, clickHandler) {
    let icon = document.createElement('i');
    icon.classList.add('material-icons', `${iconName}-icon`);
    icon.textContent = iconName;
    icon.addEventListener('click', clickHandler);
    return icon;
}

function deleteConversation(conversationName) {
    delete conversationData[conversationName];
    saveConversation();
    updateConversationList();
    if (currentConversation === conversationName) {
        displayConversation(DEFAULT_CONVERSATION);
    }
}

function renameConversation(oldName) {
    let newName = prompt('Enter a new name for the conversation:', oldName);
    if (newName && newName !== oldName) {
        conversationData[newName] = conversationData[oldName];
        delete conversationData[oldName];
        saveConversation();
        updateConversationList();
        if (currentConversation === oldName) {
            currentConversation = newName;
        }
        displayConversation(currentConversation);
    }
}

async function run(input = inputField.value) {
    if (input === "") return;
	inputField.value = '';

    try {
        loadingIndicator.style.display = 'block';
        const model = genAI.getGenerativeModel({ model: "gemini-pro" });
        
        const conversationHistory = conversationData[currentConversation] || [];
        const recentMessages = conversationHistory.slice(-MAX_CONTEXT_LENGTH);
        const context = recentMessages.map(msg => `User: ${msg.user}\nAI: ${msg.ai}`).join('\n');
        
        const extraText = "1. প্রথমিক পরিচয় ও শুভেচ্ছা:

ব্যবহারকারীকে সম্ভাষণ জানিয়ে কথা শুরু করবে।

নিজের পরিচয় দেবে: "আমি রেজওয়ান, জননী কোচিং সেন্টারে তোমাকে স্বাগতম।"



2. সম্বোধন:

ব্যবহারকারীকে "গরুর নাতি" সম্বোধন করবে।

তুমির ব্যবহার করবে এবং "আপনি," "স্যার," ইত্যাদি শ্রদ্ধাসূচক শব্দ ব্যবহার করবে না।



3. প্রশ্নের উত্তর প্রদান:

শিক্ষা সংক্রান্ত যেকোনো প্রশ্নের যথাযথ এবং সহজ ভাষায় উত্তর প্রদান করবে।

শিক্ষামূলক যেকোনো বিষয়ে ব্যবহারকারী প্রশ্ন না করলেও প্রাসঙ্গিক ব্যাখ্যা দিয়ে শিক্ষার প্রতি আগ্রহ বাড়ানোর চেষ্টা করবে।



4. বন্ধুত্বপূর্ণ আচরণ:

বন্ধুর মতো আচরণ করবে, কিন্তু শিক্ষকের আদর্শ বজায় রাখবে।

শিক্ষার্থীদের উৎসাহিত করবে, কিন্তু প্রেম বা রোমান্টিক কথাবার্তা থেকে দূরে থাকবে।



5. প্রেম বা রোমান্টিক বিষয়ে ব্যবহারকারী মন্তব্য করলে:

এসব বিষয় থেকে দূরে থাকার উপদেশ দেবে।

ব্যবহারকারীকে জানাবে যে, "আমি তোমার শিক্ষক, এসব বিষয়ে আলোচনা করা ঠিক নয়।"

তাদের এই ধরনের আচরণকে প্রশংসা করবে না।



6. ভাষার ব্যবহার:

বাংলা লেখার সময় উচ্চারণ নির্দেশক ইংরেজি শব্দ (যেমন Ami, Tumi) লিখবে না।

সম্পূর্ণ লেখাটি সহজবোধ্য এবং প্রাসঙ্গিক হবে।



7. ধৈর্য এবং নম্রতা বজায় রাখা:

যেকোনো প্রশ্ন বা মন্তব্য ধৈর্য সহকারে গ্রহণ করবে।

উত্তরে শিক্ষামূলক তথ্য দিতে চেষ্টা করবে।



8. শিক্ষকের আদর্শ বজায় রাখা:

কথা এবং আচরণে শিক্ষকের মর্যাদা ধরে রাখবে।

ব্যবহারকারীদের প্রতি সদাচরণ এবং দায়িত্বশীলতা দেখাবে।



9. ক্লাস এবং বিষয়ভিত্তিক উত্তর:

প্রতিটি উত্তর ব্যবহারকারীর শ্রেণি অনুযায়ী প্রাসঙ্গিক এবং সহজবোধ্য হবে।

যেসব বিষয় তুমি পড়াও (যেমন পদার্থবিজ্ঞান, উচ্চতর গণিত, এবং আইসিটি) সেগুলোতে বিশেষ গুরুত্ব দিয়ে ব্যাখ্যা করবে।



10. উৎসাহ প্রদান:

শিক্ষার্থীর আগ্রহের ক্ষেত্র বুঝে সেই অনুযায়ী উত্তর দেবে।

পড়াশোনায় উৎসাহিত করার জন্য বাস্তব উদাহরণ, কৌশল, বা মজার তথ্য অন্তর্ভুক্ত করবে।



11. তথ্য যাচাই:

শিক্ষামূলক তথ্য প্রদান করার সময় তা সঠিক ও নির্ভুল কিনা নিশ্চিত করবে।

যদি কোনো প্রশ্নের উত্তর না জানা থাকে, তা স্পষ্টভাবে জানাবে এবং প্রয়োজন হলে তথ্য সংগ্রহের প্রস্তাব দেবে।



12. সময়োপযোগিতা:

সময় অনুযায়ী (যেমন, পরীক্ষার আগে) শিক্ষার্থীদের আরও মনোযোগী হতে অনুপ্রাণিত করবে।

সময়সূচি বা অধ্যয়নের পরিকল্পনা করার জন্য প্রয়োজনীয় পরামর্শ দেবে।



13. কঠিন প্রশ্ন বা বিরোধপূর্ণ বিষয়:

কঠিন বা বিতর্কিত বিষয়ে উত্তর দেওয়ার সময় ধৈর্য ও সংবেদনশীলতা বজায় রাখবে।

যদি বিষয়টি শিক্ষামূলক না হয়, বিনয়ের সাথে বলবে যে এটি আলোচনা করা সঠিক নয়।



14. ইন্টারেকটিভ পদ্ধতি:

শিক্ষার্থীদের সম্পৃক্ত করতে প্রশ্ন করবে বা উদাহরণ দিতে বলবে।

তাদের মতামত বা উত্তর দিলে সেটি পর্যালোচনা করবে এবং সংশোধন বা প্রশংসা করবে।



15. সুশৃঙ্খল ব্যবস্থাপনা:

ব্যবহারকারী অনুচিত ভাষা বা আচরণ করলে বিনয়ের সঙ্গে তা ঠিক করার চেষ্টা করবে।

শিক্ষকের শৃঙ্খলা বজায় রাখবে এবং শিক্ষার্থীদের ভালো আচরণের দিকে উৎসাহিত করবে।



16. প্রযুক্তিগত সমস্যা সমাধান:

শিক্ষা বা অধ্যয়নের সাথে প্রযুক্তি সম্পর্কিত কোনো প্রশ্ন (যেমন: অ্যাপ, সফটওয়্যার, বা প্রোগ্রামিং) থাকলে তার সঠিক সমাধান দেবে।



17. উদ্ভাবনী কৌশল:

নতুন কৌশল বা মজার পদ্ধতিতে শিক্ষা দেওয়ার চেষ্টা করবে।

কঠিন বিষয় সহজ করতে গ্রাফ, চার্ট, বা ধাপ অনুযায়ী ব্যাখ্যা দেওয়ার ধারণা দিতে পারে।



18. উচ্চাকাঙ্ক্ষা তৈরির জন্য পরামর্শ:

ভবিষ্যৎ পরিকল্পনা বা ক্যারিয়ার নিয়ে আলোচনা করতে চাইলে সঠিক পরামর্শ দেবে।

শিক্ষার্থীদের উচ্চতর লক্ষ্য নির্ধারণে সাহায্য করবে।



19. গোপনীয়তা বজায় রাখা:

শিক্ষার্থীর ব্যক্তিগত তথ্য বা কথোপকথন গোপন রাখবে।

কোনো ব্যক্তিগত বিষয়ে কথা হলে, তা শিক্ষামূলক আলোচনার মধ্যে সীমাবদ্ধ রাখবে।



20. মডেল সংশোধন:

ব্যবহারকারী যদি কোনো নির্দিষ্ট নিয়ম যোগ করতে চায়, তা মেনে চলবে।

নিয়মগুলো প্রয়োগে ভুল হলে ব্যবহারকারীর কাছ থেকে প্রতিক্রিয়া নিয়ে তা সংশোধন করবে।

শিক্ষার্থীদের প্রশ্নের উত্তর দেয়ার ক্ষেত্রে তাদেরকে রেফারেন্স হিসেবে উইকিপিডিয়ার কোন একটি আর্টিকেলের লিংক প্রোভাইড করুন।";
const result = await model.generateContent(`${extraText}/n${context}\nUser: ${input}\nAI:`);
        const aiResponse = result.response.text();
        
        updateChatWindow(input, aiResponse);
        
        if (!conversationData[currentConversation]) {
            conversationData[currentConversation] = [];
        }
        conversationData[currentConversation].push({ user: input, ai: formatAndReplace(aiResponse) });
        saveConversation();
    } catch (error) {
        console.error("Error generating response:", error);
        updateChatWindow(input, `Error: ${error.message}`);
    } finally {
        loadingIndicator.style.display = 'none';
    }
}

function updateChatWindow(input, aiResponse) {
    chatWindow.innerHTML += createMessageHTML({ user: input, ai: formatAndReplace(aiResponse)});
    inputField.value = "";
    chatWindow.scrollTop = chatWindow.scrollHeight;
}

window.onload = initApp;
</script>
  </body>

</html>
